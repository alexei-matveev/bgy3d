;;;
;;; Copyright (c) 2013 Alexei Matveev
;;;
;;; Code to write a GAMESS-UK punch file.
;;;
(define-module (guile punch-file)
  #:use-module (srfi srfi-1)            ; list manipulation
  #:use-module (guile molecule)         ; site representation
  #:use-module (guile utils)            ; angstrom->bohr
  #:export
  (write-punch-file))

;;;
;;; Brain-dead implementation of cubic root:
;;;
(define (cubic-root n)
  (let loop ((x 0))
    (if (< n (* x x x))
        (- x 1)
        (loop (+ 1 x)))))

;;;
;;; This writes a GAMESS-UK punch file to the current output port. See
;;; interfaces/filepunch.py   in  CCP1   GUI  repo.    To  disentangle
;;; dependencies the  function takes  a list of  vector lengths  and a
;;; list  of so-called  iterators. Each  iterator is  a  function that
;;; accepts a (print) callback to be invoked for each vector element.
;;;
(define (write-punch-file solute lens vecs settings)
  (define (header alist)
    (for-each (lambda (pair)
                (format #t "~a=~a " (car pair) (cdr pair)))
              alist)
    (format #t "\n"))
  ;;
  ;; File title:
  ;;
  (header '((block . title) (records . 1)))
  (format #t "This file was generated by BGY3d\n")
  ;;
  ;; Description of the solute:
  ;;
  (header '((block . fragment) (records . 0)))
  (header '((block . title) (records . 1)))
  (format #t "~a\n" (molecule-name solute))
  (header `((block . coordinates)
            (records . (unquote (length (molecule-sites solute))))))
  (for-each (lambda (site)
              (format #t "~a ~a ~a ~a\n"
                      (site-name site)
                      (angstrom->bohr (site-x site)) ; punch file is in AU
                      (angstrom->bohr (site-y site))
                      (angstrom->bohr (site-z site))))
            (molecule-sites solute))
  ;;
  ;; Description of the bonds:
  ;;
  (header '((block . connectivity) (records . 0)))
  ;; (format #t "1 2\n")                   ; FIXME: real ones
  ;;
  ;; Grid data:
  ;;
  (let loop ((lens lens)
             (vecs vecs)
             (vec-id 0))
    (if (not (null? vecs))
        (let* ((vec     (first vecs))
               (len     (first lens))
               (n       (cubic-root len))
               (L       (or (assq-ref settings 'L) 10.0))
               (L       (angstrom->bohr L))   ; punch file is in AU
               (S       (* L (/ (- n 2) n)))) ; off-by-one on a 2L interval
          (header '((block . data) (records . 0)))
          (header '((block . grid_title) (records . 1)))
          (format #t "Solvent site hole density ~a\n" vec-id)
          ;;
          ;; Only  the number  of points "n"  is being  interpreted by
          ;; CCP1 GUI:
          ;;
          (header '((block . grid_axes) (records . 3)))
          (format #t "~a   0.000000 ~a 0 au xaxis\n" n (+ L S))
          (format #t "~a   0.000000 ~a 0 au yaxis\n" n (+ L S))
          (format #t "~a   0.000000 ~a 0 au zaxis\n" n (+ L S))
          ;;
          ;; The grid mapping block consists of six triples of floats:
          ;;
          ;;   O    A
          ;;   .    B
          ;;   .    C
          ;;
          ;; with  positions marked by dot apparently  ignored by CCP1
          ;; GUI.  All four points,  O, A, B,  and C, correspond  to a
          ;; grid point  of a regular grid at  four corners. Beware of
          ;; off-by-one errors when  converting periodic grids to this
          ;; representation:  if, say, the  left corner is at  -L then
          ;; its  periodic  image  to  the  right  is  at +L  but  the
          ;; rightmost point of the unique  grid portion is at S = L -
          ;; h, with h = 2L/n:
          ;;
          (header '((block . grid_mapping) (records . 3)))
          (format #t "~a ~a ~a  ~a ~a ~a\n" (- L) (- L) (- L) (+ S) (- L) (- L))
          (format #t "~a ~a ~a  ~a ~a ~a\n" (- L) (- L) (- L) (- L) (+ S) (- L))
          (format #t "~a ~a ~a  ~a ~a ~a\n" (- L) (- L) (- L) (- L) (- L) (+ S))
          ;;
          ;; Actual numeric data:
          ;;
          (header `((block . grid_data)
                    (records . (unquote len))
                    (elements . 1)))
          ;;
          ;; Invoke an iterator with a callback that prints each
          ;; value:
          ;;
          (vec (lambda (x) (format #t "~a\n" (- x 1.0))))
          (loop (cdr lens)
                (cdr vecs)
                (+ 1 vec-id))))))

