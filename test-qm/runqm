#!/home/matveev/darcs/ttfs-mac/guile-qm
;;; -*- mode: scheme; -*- vim: set syntax=scheme:
!#
;;;
;;; This script uses both PG  and BGY3d functionality, so set the path
;;; accordingly and use the proper interpreter in the shebang line.
;;;
(cond-expand
 ((not guile-2) (use-modules (ice-9 syncase))) ; eval-when for 1.8
 (else))                                ; nothing

(eval-when
 (eval load compile)      ; extend %load-path at compile time with 2.0
 (set! %load-path (cons "/home/matveev/darcs/bgy3d" %load-path))
 (set! %load-path (cons "/home/matveev/darcs/ttfs-mac" %load-path)))

;;;
;;; FIXME: can we make PG to look up the names in a specific module to
;;; avoid importing staff that is not immediately used:
;;;
(use-modules (srfi srfi-1)
             (ice-9 pretty-print)
             ((guile paragauss)
              #:select (qm-main))
             ;;
             ;; This one is called from se_scheduling_module to
             ;; convert MPTS problem on behalf of the blocked
             ;; egiensolver.
             ;;
             ((guile scheduling)
              #:select (qm-mpts->npts))
             ;;
             ;; BGY3d functionality:
             ;;
             ((guile bgy3d)
              #:select (bgy3d-api-version
                        solvent/solvent
                        solute/solvent
                        bgy3d-restart-destroy)))

;;;
;;; ParaGauss looks up these names in the top-level environment:
;;;
;;;   bgy3d-api-version
;;;   bgy3d-solvent             (v1)
;;;   bgy3d-solute-hook         (v1)
;;;   bgy3d-restart-destroy     (v1)
;;;
;;; Some of  these names are  imported from (guile bgy3d)  module (see
;;; above).  Others are defined here --- e.g. we will bind a hook to a
;;; closure over input parameters later:
;;;
(define bgy3d-solvent (if #f #f))       ; unspecified yet
(define bgy3d-solute-hook (if #f #f))   ; unspecified yet

;;;
;;; The   input  file   is  supposed   to  contain   (at   least)  two
;;; s-expressions. The  first one is the  usual PG input as  a list of
;;; forms  (namelists).  The second  one is  intended for  BGY3d.  The
;;; format and content of the latter is to be defined yet.
;;;
;;; Let it  be a list of  forms, for the moment.  The (solute "table")
;;; form  specifies   the  dictionary  to  look   up  the  force-field
;;; parameters for the sites used in QM calculation, e.g.:
;;;
;;;   ((solute "hydrogen chloride"))
;;;
;;; Note the  extra pair of  parens, it should  be a *list*  of forms.
;;; FIXME: the input would need to specify the solvent as well. So far
;;; default solvent is used.
;;;
(let* ((argv (command-line))
       (path (second argv))            ; first arg is the program name
       (opts (with-input-from-file path
               (lambda ()
                 (read)                 ; skip PG input
                 (read)))))             ; return BGY3d input
  (pretty-print (list 'ARGV: argv))
  (pretty-print (list 'OPTS: opts))
  ;;
  ;; PG calls bgy3d-solute-hook with solute sites (having fake force
  ;; field parameters), a pointer to a function returning the density
  ;; and a pointer token for the opaque restart info object to
  ;; facilitate SCF iterations:
  ;;
  ;;   (bgy3d-solute-hook solute-sites
  ;;                      electron-density-funptr
  ;;                      restart-info-ptr)
  ;;
  ;; QM code cannot and should not be required to provide more info.
  ;; In this case we call solute/solvent with a the (medium model
  ;; related) input read from the file prepended to the list of
  ;; arguments:
  ;;
  (set! bgy3d-solute-hook
        (lambda args
          (apply solute/solvent opts args))) ; -> (potential . restart)
  ;;
  ;; This hook  is called from PG without  arguments. However, we pass
  ;; model-related  input "opts" from the  file at "path"  to the code
  ;; doing the actual work:
  ;;
  (set! bgy3d-solvent
        (lambda args (solvent/solvent opts)))
  ;;
  ;; Call  PG with arguments as  supplied in the  command line. FIXME:
  ;; Here is the conflict.  Who should interprete the command line? QM
  ;; or solvent  code?  As of now the command line  is reserved for QM
  ;; code:
  ;;
  (qm-main argv))
